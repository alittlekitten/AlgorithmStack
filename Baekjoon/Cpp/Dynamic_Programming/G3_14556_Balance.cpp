#include <iostream>
#include <string>
using namespace std;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	// 14456 Balance
	// dp

	// 2^1 를 맨 마지막에 두는 경우 -> 나머지 요소들을 배치하고 나면 2^2는 양쪽 아무데나 둬도 된다
	// 2^2 를 맨 마지막에 두는 경우 -> 나머지 요소들을 배치하고 나면 2^2는 양쪽 아무데나 둬도 된다
	// 2^N-1을 맨 마지막에 두는 경우 -> 나머지 요소들을 배치하고 나면 2^N-1은 양쪽 아무데나 둬도 된다. (중간에 2^N이 왼쪽으로 들어가면 그 순간 틀린게 되버리기 떄문)
	// ,,, 2^N 을 맨 마지막에 두는 경우 -> 나머지 요소를 배치하고 나면 반드시 오른쪽에 둬야한다.
	// 2^N-1까지의 요소들을 배치하는 경우의 수를 k라고 하자
	// 각 요소들을 마지막에 넣는 경우들을 생각하면 전체 경우의 수는 2 * (N-1) * k + k = (2N - 1) k
	// 결국 점화식은 k(n) = (2n-1) * k(n-1)
	// 원래라면 dp로 풀어야 하지만, 점화식을 구했기 때문에 굳이 dp용 배열이 필요하지 않고 바로 때려박을 수 있을듯?

	int n;
	long long dp = 1; // n이 1일 때의 경우의 수는 1
	cin >> n;

	for (int i = 2; i <= n; ++i) {
		dp = ((2 * i - 1) * dp) % 1000000009; // 곱연산이기 때문에 %로 나누어도 나머지는 항상 같다
	}

	cout << dp;

	
	return 0;
}
